
## UniTask WebGL 빌드 테스트

### 개요

싱글 스레드만 지원하는 WebGL 빌드에서 UniTask를 사용해 비동기로 동작이 가능한지 확인

WebGL로 빌드하는 경우, 기존 Task를 사용해 비동기적으로 동작하던 부분들도 자동으로 동기적으로 동작하게끔 수정됨

UniTask는 단일스레드로 동작하기 때문에 WebGL에서 정상 동작하는지 테스트

---

### 테스트

1. UniTask 비동기로 5초 대기 시작
2. 1번을 대기하면서, 첫번째 쿼드 회전 시작
    
    ⇒ 이 때, 비동기 5초동안 계속 회전해야한다
    
3. 비동기 5초 종료 후, 두번째 쿼드 회전 시작
4. 동기로 5초 대기 
    
    ⇒ 이때, 두 쿼드는 멈춰야한다. 
    

---

### 결과

첫번째 쿼드는 비동기적으로 동작함

두번째 Thread.Sleep은 동작하지 않아, 즉시 동기 5초

`Thread.Sleep` 같은 C#의 스레드 같은 경우, WebGL 빌드에서 지원하지 않아 Thread(5000)는 지연없이 즉시 넘어감 (고로 Task관련도 안되는게 아닐까 싶음)

---

### 수정 및 결과

While문을 돌려 BusyWait를 돌도록 하여 강제로 지연시킴 → 원하던대로 5초후 로그 출력

그러나 반복문이라 프리징 현상이 일어남

만약 루프 안에 await UniTask.Yield()를 넣어 프레임을 양보시키면 프리징 현상을 해결 할 수 있음

---

### 결론

비동기로 어떠한 기능을 동작시키고 대기할 순 있다. 

하지만 루프같이 CPU 점유가 높은 작업의 경우, 화면이 멈출 수 있음

고로 중간에 UniTask.Yield를 섞어 다른 작업이 동작할 수 있게끔해주자

Task 같은 문법처럼 쓰여서 헷갈리지만 사실 그냥 코루틴이었던거임~~